'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* fluent@0.3.1 */
(function (global, factory) {
  (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define('fluent', ['exports'], factory) : factory(global.Fluent = global.Fluent || {});
})(undefined, function (exports) {
  'use strict';

  /*  eslint no-magic-numbers: [0]  */

  var MAX_PLACEABLES = 100;

  /**
   * The `Parser` class is responsible for parsing FTL resources.
   *
   * It's only public method is `getResource(source)` which takes an FTL string
   * and returns a two element Array with an Object of entries generated from the
   * source as the first element and an array of SyntaxError objects as the
   * second.
   *
   * This parser is optimized for runtime performance.
   *
   * There is an equivalent of this parser in syntax/parser which is
   * generating full AST which is useful for FTL tools.
   */

  var RuntimeParser = function () {
    function RuntimeParser() {
      _classCallCheck(this, RuntimeParser);
    }

    _createClass(RuntimeParser, [{
      key: 'getResource',

      /**
       * @param {string} string
       * @returns {Array<Object, Array>}
       */
      value: function getResource(string) {
        this._source = string;
        this._index = 0;
        this._length = string.length;

        var entries = {};
        var errors = [];

        this.getWS();
        while (this._index < this._length) {
          try {
            this.getEntry(entries);
          } catch (e) {
            if (e instanceof SyntaxError) {
              errors.push(e);

              var nextEntity = this._findNextEntryStart();
              this._index = nextEntity === -1 ? this._length : nextEntity;
            } else {
              throw e;
            }
          }
          this.getWS();
        }

        return [entries, errors];
      }
    }, {
      key: 'getEntry',
      value: function getEntry(entries) {
        // The pointer here should either be at the beginning of the file
        // or right after new line.
        if (this._index !== 0 && this._source[this._index - 1] !== '\n') {
          throw this.error('Expected new line and a new entry');
        }

        var ch = this._source[this._index];

        // We don't care about comments or sections at runtime
        if (ch === '/') {
          this.getComment();
          return;
        }

        if (ch === '[') {
          this.getSection();
          return;
        }

        if (ch !== '\n') {
          this.getMessage(entries);
        }
      }
    }, {
      key: 'getSection',
      value: function getSection() {
        this._index += 1;
        if (this._source[this._index] !== '[') {
          throw this.error('Expected "[[" to open a section');
        }

        this._index += 1;

        this.getLineWS();
        this.getSymbol();
        this.getLineWS();

        if (this._source[this._index] !== ']' || this._source[this._index + 1] !== ']') {
          throw this.error('Expected "]]" to close a section');
        }

        this._index += 2;

        // sections are ignored in the runtime ast
        return undefined;
      }
    }, {
      key: 'getMessage',
      value: function getMessage(entries) {
        var id = this.getIdentifier();
        var attrs = null;
        var tags = null;

        this.getLineWS();

        var ch = this._source[this._index];

        var val = void 0;

        if (ch === '=') {
          this._index++;

          this.getLineWS();

          val = this.getPattern();
        } else {
          this.getWS();
        }

        ch = this._source[this._index];

        if (ch === '\n') {
          this._index++;
          this.getLineWS();
          ch = this._source[this._index];
        }

        if (ch === '.') {
          attrs = this.getAttributes();
        }

        if (ch === '#') {
          if (attrs !== null) {
            throw this.error('Tags cannot be added to a message with attributes.');
          }
          tags = this.getTags();
        }

        if (tags === null && attrs === null && typeof val === 'string') {
          entries[id] = val;
        } else {
          if (val === undefined) {
            if (tags === null && attrs === null) {
              throw this.error('Expected a value (like: " = value") or\n            an attribute (like: ".key = value")');
            }
          }

          entries[id] = { val: val };
          if (attrs) {
            entries[id].attrs = attrs;
          }
          if (tags) {
            entries[id].tags = tags;
          }
        }
      }
    }, {
      key: 'getWS',
      value: function getWS() {
        var cc = this._source.charCodeAt(this._index);
        // space, \n, \t, \r
        while (cc === 32 || cc === 10 || cc === 9 || cc === 13) {
          cc = this._source.charCodeAt(++this._index);
        }
      }
    }, {
      key: 'getLineWS',
      value: function getLineWS() {
        var cc = this._source.charCodeAt(this._index);
        // space, \t
        while (cc === 32 || cc === 9) {
          cc = this._source.charCodeAt(++this._index);
        }
      }
    }, {
      key: 'getIdentifier',
      value: function getIdentifier() {
        var start = this._index;
        var cc = this._source.charCodeAt(this._index);

        if (cc >= 97 && cc <= 122 || // a-z
        cc >= 65 && cc <= 90 || // A-Z
        cc === 95) {
          // _
          cc = this._source.charCodeAt(++this._index);
        } else {
          throw this.error('Expected an identifier (starting with [a-zA-Z_])');
        }

        while (cc >= 97 && cc <= 122 || // a-z
        cc >= 65 && cc <= 90 || // A-Z
        cc >= 48 && cc <= 57 || // 0-9
        cc === 95 || cc === 45) {
          // _-
          cc = this._source.charCodeAt(++this._index);
        }

        return this._source.slice(start, this._index);
      }
    }, {
      key: 'getSymbol',
      value: function getSymbol() {
        var name = '';

        var start = this._index;
        var cc = this._source.charCodeAt(this._index);

        if (cc >= 97 && cc <= 122 || // a-z
        cc >= 65 && cc <= 90 || // A-Z
        cc === 95 || cc === 32) {
          //  _
          cc = this._source.charCodeAt(++this._index);
        } else if (name.length === 0) {
          throw this.error('Expected a keyword (starting with [a-zA-Z_])');
        }

        while (cc >= 97 && cc <= 122 || // a-z
        cc >= 65 && cc <= 90 || // A-Z
        cc >= 48 && cc <= 57 || // 0-9
        cc === 95 || cc === 45 || cc === 32) {
          //  _-
          cc = this._source.charCodeAt(++this._index);
        }

        // If we encountered the end of name, we want to test is the last
        // collected character is a space.
        // If it is, we will backtrack to the last non-space character because
        // the keyword cannot end with a space character.
        while (this._source.charCodeAt(this._index - 1) === 32) {
          this._index--;
        }

        name += this._source.slice(start, this._index);

        return { type: 'sym', name: name };
      }
    }, {
      key: 'getString',
      value: function getString() {
        var value = '';

        while (++this._index < this._length) {
          var ch = this._source[this._index];

          if (ch === '"') {
            break;
          }

          if (ch === '\n') {
            break;
          }

          value += ch;
        }

        this._index++;
        return value;
      }

      // We're going to first try to see if the pattern is simple.
      // If it is we can just look for the end of the line and read the string.
      //
      // Then, if either the line contains a placeable opening `{` or the
      // next line starts with a pipe `|`, we switch to complex pattern.

    }, {
      key: 'getPattern',
      value: function getPattern() {
        var start = this._index;
        var eol = this._source.indexOf('\n', this._index);

        if (eol === -1) {
          eol = this._length;
        }

        var line = start !== eol ? this._source.slice(start, eol) : undefined;

        if (line !== undefined && line.includes('{')) {
          return this.getComplexPattern();
        }

        this._index = eol + 1;

        if (this._source[this._index] === ' ') {
          this._index = start;
          return this.getComplexPattern();
        }

        return line;
      }

      /* eslint-disable complexity */

    }, {
      key: 'getComplexPattern',
      value: function getComplexPattern() {
        var buffer = '';
        var content = [];
        var placeables = 0;

        var ch = this._source[this._index];

        // If the string starts with \", \{ or \\ skip the first `\` and add the
        // following character to the buffer without interpreting it.
        if (ch === '\\' && (this._source[this._index + 1] === '"' || this._source[this._index + 1] === '{' || this._source[this._index + 1] === '\\')) {
          buffer += this._source[this._index + 1];
          this._index += 2;
          ch = this._source[this._index];
        }

        while (this._index < this._length) {
          // This block handles multi-line strings combining strings seaprated
          // by new line and `|` character at the beginning of the next one.
          if (ch === '\n') {
            this._index++;
            if (this._source[this._index] !== ' ') {
              break;
            }
            this.getLineWS();

            if (this._source[this._index] === '}' || this._source[this._index] === '[' || this._source[this._index] === '*' || this._source[this._index] === '#' || this._source[this._index] === '.') {
              break;
            }

            if (buffer.length) {
              buffer += '\n';
            }
            ch = this._source[this._index];
            continue;
          } else if (ch === '\\') {
            var ch2 = this._source[this._index + 1];
            if (ch2 === '"' || ch2 === '{') {
              ch = ch2;
              this._index++;
            }
          } else if (ch === '{') {
            // Push the buffer to content array right before placeable
            if (buffer.length) {
              content.push(buffer);
            }
            if (placeables > MAX_PLACEABLES - 1) {
              throw this.error('Too many placeables, maximum allowed is ' + MAX_PLACEABLES);
            }
            buffer = '';
            content.push(this.getPlaceable());

            this._index++;

            ch = this._source[this._index];
            placeables++;
            continue;
          }

          if (ch) {
            buffer += ch;
          }
          this._index++;
          ch = this._source[this._index];
        }

        if (content.length === 0) {
          return buffer.length ? buffer : undefined;
        }

        if (buffer.length) {
          content.push(buffer);
        }

        return content;
      }
      /* eslint-enable complexity */

    }, {
      key: 'getPlaceable',
      value: function getPlaceable() {
        var start = ++this._index;

        this.getWS();

        if (this._source[this._index] === '*' || this._source[this._index] === '[' && this._source[this._index + 1] !== ']') {
          var _variants = this.getVariants();

          return {
            type: 'sel',
            exp: null,
            vars: _variants[0],
            def: _variants[1]
          };
        }

        // Rewind the index and only support in-line white-space now.
        this._index = start;
        this.getLineWS();

        var selector = this.getSelectorExpression();
        var variants = void 0;

        this.getWS();

        var ch = this._source[this._index];

        // If the expression is followed by `->` we're going to collect
        // its members and return it as a select expression.
        if (ch !== '}') {
          if (ch !== '-' || this._source[this._index + 1] !== '>') {
            throw this.error('Expected "}", "," or "->"');
          }

          this._index += 2; // ->

          this.getLineWS();

          if (this._source[this._index] !== '\n') {
            throw this.error('Variants should be listed in a new line');
          }

          this.getWS();

          variants = this.getVariants();

          if (variants[0].length === 0) {
            throw this.error('Expected members for the select expression');
          }
        }

        if (variants === undefined) {
          return selector;
        }
        return {
          type: 'sel',
          exp: selector,
          vars: variants[0],
          def: variants[1]
        };
      }
    }, {
      key: 'getSelectorExpression',
      value: function getSelectorExpression() {
        var literal = this.getLiteral();

        if (literal.type !== 'ref') {
          return literal;
        }

        if (this._source[this._index] === '.') {
          this._index++;

          var name = this.getIdentifier();
          this._index++;
          return {
            type: 'attr',
            id: literal,
            name: name
          };
        }

        if (this._source[this._index] === '[') {
          this._index++;

          var key = this.getVariantKey();
          this._index++;
          return {
            type: 'var',
            id: literal,
            key: key
          };
        }

        if (this._source[this._index] === '(') {
          this._index++;
          var args = this.getCallArgs();

          this._index++;

          literal.type = 'fun';

          return {
            type: 'call',
            fun: literal,
            args: args
          };
        }

        return literal;
      }
    }, {
      key: 'getCallArgs',
      value: function getCallArgs() {
        var args = [];

        if (this._source[this._index] === ')') {
          return args;
        }

        while (this._index < this._length) {
          this.getLineWS();

          var exp = this.getSelectorExpression();

          // MessageReference in this place may be an entity reference, like:
          // `call(foo)`, or, if it's followed by `:` it will be a key-value pair.
          if (exp.type !== 'ref' || exp.namespace !== undefined) {
            args.push(exp);
          } else {
            this.getLineWS();

            if (this._source[this._index] === ':') {
              this._index++;
              this.getLineWS();

              var val = this.getSelectorExpression();

              // If the expression returned as a value of the argument
              // is not a quote delimited string or number, throw.
              //
              // We don't have to check here if the pattern is quote delimited
              // because that's the only type of string allowed in expressions.
              if (typeof val === 'string' || Array.isArray(val) || val.type === 'num') {
                args.push({
                  type: 'narg',
                  name: exp.name,
                  val: val
                });
              } else {
                this._index = this._source.lastIndexOf(':', this._index) + 1;
                throw this.error('Expected string in quotes, number.');
              }
            } else {
              args.push(exp);
            }
          }

          this.getLineWS();

          if (this._source[this._index] === ')') {
            break;
          } else if (this._source[this._index] === ',') {
            this._index++;
          } else {
            throw this.error('Expected "," or ")"');
          }
        }

        return args;
      }
    }, {
      key: 'getNumber',
      value: function getNumber() {
        var num = '';
        var cc = this._source.charCodeAt(this._index);

        // The number literal may start with negative sign `-`.
        if (cc === 45) {
          num += '-';
          cc = this._source.charCodeAt(++this._index);
        }

        // next, we expect at least one digit
        if (cc < 48 || cc > 57) {
          throw this.error('Unknown literal "' + num + '"');
        }

        // followed by potentially more digits
        while (cc >= 48 && cc <= 57) {
          num += this._source[this._index++];
          cc = this._source.charCodeAt(this._index);
        }

        // followed by an optional decimal separator `.`
        if (cc === 46) {
          num += this._source[this._index++];
          cc = this._source.charCodeAt(this._index);

          // followed by at least one digit
          if (cc < 48 || cc > 57) {
            throw this.error('Unknown literal "' + num + '"');
          }

          // and optionally more digits
          while (cc >= 48 && cc <= 57) {
            num += this._source[this._index++];
            cc = this._source.charCodeAt(this._index);
          }
        }

        return {
          type: 'num',
          val: num
        };
      }
    }, {
      key: 'getAttributes',
      value: function getAttributes() {
        var attrs = {};

        while (this._index < this._length) {
          var ch = this._source[this._index];

          if (ch !== '.') {
            break;
          }
          this._index++;

          var key = this.getIdentifier();

          this.getLineWS();

          this._index++;

          this.getLineWS();

          var val = this.getPattern();

          if (typeof val === 'string') {
            attrs[key] = val;
          } else {
            attrs[key] = {
              val: val
            };
          }

          this.getWS();
        }

        return attrs;
      }
    }, {
      key: 'getTags',
      value: function getTags() {
        var tags = [];

        while (this._index < this._length) {
          var ch = this._source[this._index];

          if (ch !== '#') {
            break;
          }
          this._index++;

          var symbol = this.getSymbol();

          tags.push(symbol.name);

          this.getWS();
        }

        return tags;
      }
    }, {
      key: 'getVariants',
      value: function getVariants() {
        var variants = [];
        var index = 0;
        var defaultIndex = void 0;

        while (this._index < this._length) {
          var ch = this._source[this._index];

          if ((ch !== '[' || this._source[this._index + 1] === '[') && ch !== '*') {
            break;
          }
          if (ch === '*') {
            this._index++;
            defaultIndex = index;
          }

          if (this._source[this._index] !== '[') {
            throw this.error('Expected "["');
          }

          this._index++;

          var key = this.getVariantKey();

          this.getLineWS();

          var variant = {
            key: key,
            val: this.getPattern()
          };
          variants[index++] = variant;

          this.getWS();
        }

        return [variants, defaultIndex];
      }

      // VariantKey may be a Keyword or Number

    }, {
      key: 'getVariantKey',
      value: function getVariantKey() {
        var cc = this._source.charCodeAt(this._index);
        var literal = void 0;

        if (cc >= 48 && cc <= 57 || cc === 45) {
          literal = this.getNumber();
        } else {
          literal = this.getSymbol();
        }

        if (this._source[this._index] !== ']') {
          throw this.error('Expected "]"');
        }

        this._index++;
        return literal;
      }
    }, {
      key: 'getLiteral',
      value: function getLiteral() {
        var cc = this._source.charCodeAt(this._index);
        if (cc >= 48 && cc <= 57 || cc === 45) {
          return this.getNumber();
        } else if (cc === 34) {
          // "
          return this.getString();
        } else if (cc === 36) {
          // $
          this._index++;
          return {
            type: 'ext',
            name: this.getIdentifier()
          };
        }

        return {
          type: 'ref',
          name: this.getIdentifier()
        };
      }

      // At runtime, we don't care about comments so we just have
      // to parse them properly and skip their content.

    }, {
      key: 'getComment',
      value: function getComment() {
        var eol = this._source.indexOf('\n', this._index);

        while (eol !== -1 && this._source[eol + 1] === '/' && this._source[eol + 2] === '/') {
          this._index = eol + 3;

          eol = this._source.indexOf('\n', this._index);

          if (eol === -1) {
            break;
          }
        }

        if (eol === -1) {
          this._index = this._length;
        } else {
          this._index = eol + 1;
        }
      }
    }, {
      key: 'error',
      value: function error(message) {
        return new SyntaxError(message);
      }
    }, {
      key: '_findNextEntryStart',
      value: function _findNextEntryStart() {
        var start = this._index;

        while (true) {
          if (start === 0 || this._source[start - 1] === '\n') {
            var cc = this._source.charCodeAt(start);

            if (cc >= 97 && cc <= 122 || // a-z
            cc >= 65 && cc <= 90 || // A-Z
            cc === 95 || cc === 47 || cc === 91) {
              // _/[
              break;
            }
          }

          start = this._source.indexOf('\n', start);

          if (start === -1) {
            break;
          }
          start++;
        }

        return start;
      }
    }]);

    return RuntimeParser;
  }();

  function parse(string) {
    var parser = new RuntimeParser();
    return parser.getResource(string);
  }

  /* global Intl */

  /**
   * The `FluentType` class is the base of Fluent's type system.
   *
   * Fluent types wrap JavaScript values and store additional configuration for
   * them, which can then be used in the `valueOf` method together with a proper
   * `Intl` formatter.
   */

  var FluentType = function () {

    /**
     * Create an `FluentType` instance.
     *
     * @param   {Any}    value - JavaScript value to wrap.
     * @param   {Object} opts  - Configuration.
     * @returns {FluentType}
     */
    function FluentType(value, opts) {
      _classCallCheck(this, FluentType);

      this.value = value;
      this.opts = opts;
    }

    /**
     * Unwrap the instance of `FluentType`.
     *
     * Unwrapped values are suitable for use outside of the `MessageContext`.
     * This method can use `Intl` formatters memoized by the `MessageContext`
     * instance passed as an argument.
     *
     * @param   {MessageContext} [ctx]
     * @returns {string}
     */


    _createClass(FluentType, [{
      key: 'valueOf',
      value: function valueOf() {
        throw new Error('Subclasses of FluentType must implement valueOf.');
      }
    }]);

    return FluentType;
  }();

  var FluentNone = function (_FluentType) {
    _inherits(FluentNone, _FluentType);

    function FluentNone() {
      _classCallCheck(this, FluentNone);

      return _possibleConstructorReturn(this, (FluentNone.__proto__ || Object.getPrototypeOf(FluentNone)).apply(this, arguments));
    }

    _createClass(FluentNone, [{
      key: 'valueOf',
      value: function valueOf() {
        return this.value || '???';
      }
    }]);

    return FluentNone;
  }(FluentType);

  var FluentNumber = function (_FluentType2) {
    _inherits(FluentNumber, _FluentType2);

    function FluentNumber(value, opts) {
      _classCallCheck(this, FluentNumber);

      return _possibleConstructorReturn(this, (FluentNumber.__proto__ || Object.getPrototypeOf(FluentNumber)).call(this, parseFloat(value), opts));
    }

    _createClass(FluentNumber, [{
      key: 'valueOf',
      value: function valueOf(ctx) {
        var nf = ctx._memoizeIntlObject(Intl.NumberFormat, this.opts);
        return nf.format(this.value);
      }
    }, {
      key: 'match',
      value: function match(ctx, other) {
        if (other instanceof FluentNumber) {
          return this.value === other.value;
        }
        return false;
      }
    }]);

    return FluentNumber;
  }(FluentType);

  var FluentDateTime = function (_FluentType3) {
    _inherits(FluentDateTime, _FluentType3);

    function FluentDateTime(value, opts) {
      _classCallCheck(this, FluentDateTime);

      return _possibleConstructorReturn(this, (FluentDateTime.__proto__ || Object.getPrototypeOf(FluentDateTime)).call(this, new Date(value), opts));
    }

    _createClass(FluentDateTime, [{
      key: 'valueOf',
      value: function valueOf(ctx) {
        var dtf = ctx._memoizeIntlObject(Intl.DateTimeFormat, this.opts);
        return dtf.format(this.value);
      }
    }]);

    return FluentDateTime;
  }(FluentType);

  var FluentSymbol = function (_FluentType4) {
    _inherits(FluentSymbol, _FluentType4);

    function FluentSymbol() {
      _classCallCheck(this, FluentSymbol);

      return _possibleConstructorReturn(this, (FluentSymbol.__proto__ || Object.getPrototypeOf(FluentSymbol)).apply(this, arguments));
    }

    _createClass(FluentSymbol, [{
      key: 'valueOf',
      value: function valueOf() {
        return this.value;
      }
    }, {
      key: 'match',
      value: function match(ctx, other) {
        if (other instanceof FluentSymbol) {
          return this.value === other.value;
        } else if (typeof other === 'string') {
          return this.value === other;
        } else if (other instanceof FluentNumber) {
          var pr = ctx._memoizeIntlObject(Intl.PluralRules, other.opts);
          return this.value === pr.select(other.value);
        } else if (Array.isArray(other)) {
          var _values = other.map(function (symbol) {
            return symbol.value;
          });
          return _values.includes(this.value);
        }
        return false;
      }
    }]);

    return FluentSymbol;
  }(FluentType);

  /**
   * @overview
   *
   * The FTL resolver ships with a number of functions built-in.
   *
   * Each function take two arguments:
   *   - args - an array of positional args
   *   - opts - an object of key-value args
   *
   * Arguments to functions are guaranteed to already be instances of
   * `FluentType`.  Functions must return `FluentType` objects as well.
   */

  var builtins = {
    'NUMBER': function NUMBER(_ref, opts) {
      var _ref2 = _slicedToArray(_ref, 1),
          arg = _ref2[0];

      return new FluentNumber(arg.value, merge(arg.opts, opts));
    },
    'DATETIME': function DATETIME(_ref3, opts) {
      var _ref4 = _slicedToArray(_ref3, 1),
          arg = _ref4[0];

      return new FluentDateTime(arg.value, merge(arg.opts, opts));
    }
  };

  function merge(argopts, opts) {
    return Object.assign({}, argopts, values(opts));
  }

  function values(opts) {
    var unwrapped = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Object.keys(opts)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var name = _step.value;

        unwrapped[name] = opts[name].value;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return unwrapped;
  }

  /**
   * @overview
   *
   * The role of the Fluent resolver is to format a translation object to an
   * instance of `FluentType` or an array of instances.
   *
   * Translations can contain references to other messages or external arguments,
   * conditional logic in form of select expressions, traits which describe their
   * grammatical features, and can use Fluent builtins which make use of the
   * `Intl` formatters to format numbers, dates, lists and more into the
   * context's language.  See the documentation of the Fluent syntax for more
   * information.
   *
   * In case of errors the resolver will try to salvage as much of the
   * translation as possible.  In rare situations where the resolver didn't know
   * how to recover from an error it will return an instance of `FluentNone`.
   *
   * `MessageReference`, `VariantExpression`, `AttributeExpression` and
   * `SelectExpression` resolve to raw Runtime Entries objects and the result of
   * the resolution needs to be passed into `Type` to get their real value.
   * This is useful for composing expressions.  Consider:
   *
   *     brand-name[nominative]
   *
   * which is a `VariantExpression` with properties `id: MessageReference` and
   * `key: Keyword`.  If `MessageReference` was resolved eagerly, it would
   * instantly resolve to the value of the `brand-name` message.  Instead, we
   * want to get the message object and look for its `nominative` variant.
   *
   * All other expressions (except for `FunctionReference` which is only used in
   * `CallExpression`) resolve to an instance of `FluentType`.  The caller should
   * use the `valueOf` method to convert the instance to a native value.
   */

  // Prevent expansion of too long placeables.
  var MAX_PLACEABLE_LENGTH = 2500;

  // Unicode bidi isolation characters.
  var FSI = '\u2068';
  var PDI = '\u2069';

  /**
   * Helper for computing the total character length of a placeable.
   *
   * Used in Pattern.
   *
   * @private
   */
  function PlaceableLength(env, parts) {
    var ctx = env.ctx;

    return parts.reduce(function (sum, part) {
      return sum + part.valueOf(ctx).length;
    }, 0);
  }

  /**
   * Helper for choosing the default value from a set of members.
   *
   * Used in SelectExpressions and Type.
   *
   * @private
   */
  function DefaultMember(env, members, def) {
    if (members[def]) {
      return members[def];
    }

    var errors = env.errors;

    errors.push(new RangeError('No default'));
    return new FluentNone();
  }

  /**
   * Resolve a reference to a message to the message object.
   *
   * @private
   */
  function MessageReference(env, _ref5) {
    var name = _ref5.name;
    var ctx = env.ctx,
        errors = env.errors;

    var message = ctx.messages.get(name);

    if (!message) {
      errors.push(new ReferenceError('Unknown message: ' + name));
      return new FluentNone(name);
    }

    return message;
  }

  /**
   * Resolve an array of tags.
   *
   * @private
   */
  function Tags(env, _ref6) {
    var name = _ref6.name;
    var ctx = env.ctx,
        errors = env.errors;

    var message = ctx.messages.get(name);

    if (!message) {
      errors.push(new ReferenceError('Unknown message: ' + name));
      return new FluentNone(name);
    }

    if (!message.tags) {
      errors.push(new RangeError('No tags in message "' + name + '"'));
      return new FluentNone(name);
    }

    return message.tags.map(function (tag) {
      return new FluentSymbol(tag);
    });
  }

  /**
   * Resolve a variant expression to the variant object.
   *
   * @private
   */
  function VariantExpression(env, _ref7) {
    var id = _ref7.id,
        key = _ref7.key;

    var message = MessageReference(env, id);
    if (message instanceof FluentNone) {
      return message;
    }

    var ctx = env.ctx,
        errors = env.errors;

    var keyword = Type(env, key);

    function isVariantList(node) {
      return Array.isArray(node) && node[0].type === 'sel' && node[0].exp === null;
    }

    if (isVariantList(message.val)) {
      // Match the specified key against keys of each variant, in order.
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = message.val[0].vars[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var variant = _step2.value;

          var variantKey = Type(env, variant.key);
          if (keyword.match(ctx, variantKey)) {
            return variant;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    errors.push(new ReferenceError('Unknown variant: ' + keyword.valueOf(ctx)));
    return Type(env, message);
  }

  /**
   * Resolve an attribute expression to the attribute object.
   *
   * @private
   */
  function AttributeExpression(env, _ref8) {
    var id = _ref8.id,
        name = _ref8.name;

    var message = MessageReference(env, id);
    if (message instanceof FluentNone) {
      return message;
    }

    if (message.attrs) {
      // Match the specified name against keys of each attribute.
      for (var attrName in message.attrs) {
        if (name === attrName) {
          return message.attrs[name];
        }
      }
    }

    var errors = env.errors;

    errors.push(new ReferenceError('Unknown attribute: ' + name));
    return Type(env, message);
  }

  /**
   * Resolve a select expression to the member object.
   *
   * @private
   */
  function SelectExpression(env, _ref9) {
    var exp = _ref9.exp,
        vars = _ref9.vars,
        def = _ref9.def;

    if (exp === null) {
      return DefaultMember(env, vars, def);
    }

    var selector = exp.type === 'ref' ? Tags(env, exp) : Type(env, exp);
    if (selector instanceof FluentNone) {
      return DefaultMember(env, vars, def);
    }

    // Match the selector against keys of each variant, in order.
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = vars[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var variant = _step3.value;

        var key = Type(env, variant.key);
        var keyCanMatch = key instanceof FluentNumber || key instanceof FluentSymbol;

        if (!keyCanMatch) {
          continue;
        }

        var ctx = env.ctx;


        if (key.match(ctx, selector)) {
          return variant;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return DefaultMember(env, vars, def);
  }

  /**
   * Resolve expression to a Fluent type.
   *
   * JavaScript strings are a special case.  Since they natively have the
   * `valueOf` method they can be used as if they were a Fluent type without
   * paying the cost of creating a instance of one.
   *
   * @param   {Object} expr
   * @returns {FluentType}
   * @private
   */
  function Type(env, expr) {
    // A fast-path for strings which are the most common case, and for
    // `FluentNone` which doesn't require any additional logic.
    if (typeof expr === 'string' || expr instanceof FluentNone) {
      return expr;
    }

    // The Runtime AST (Entries) encodes patterns (complex strings with
    // placeables) as Arrays.
    if (Array.isArray(expr)) {
      return Pattern(env, expr);
    }

    switch (expr.type) {
      case 'sym':
        return new FluentSymbol(expr.name);
      case 'num':
        return new FluentNumber(expr.val);
      case 'ext':
        return ExternalArgument(env, expr);
      case 'fun':
        return FunctionReference(env, expr);
      case 'call':
        return CallExpression(env, expr);
      case 'ref':
        {
          var message = MessageReference(env, expr);
          return Type(env, message);
        }
      case 'attr':
        {
          var attr = AttributeExpression(env, expr);
          return Type(env, attr);
        }
      case 'var':
        {
          var variant = VariantExpression(env, expr);
          return Type(env, variant);
        }
      case 'sel':
        {
          var member = SelectExpression(env, expr);
          return Type(env, member);
        }
      case undefined:
        {
          // If it's a node with a value, resolve the value.
          if (expr.val !== undefined) {
            return Type(env, expr.val);
          }

          var errors = env.errors;

          errors.push(new RangeError('No value'));
          return new FluentNone();
        }
      default:
        return new FluentNone();
    }
  }

  /**
   * Resolve a reference to an external argument.
   *
   * @private
   */
  function ExternalArgument(env, _ref10) {
    var name = _ref10.name;
    var args = env.args,
        errors = env.errors;


    if (!args || !args.hasOwnProperty(name)) {
      errors.push(new ReferenceError('Unknown external: ' + name));
      return new FluentNone(name);
    }

    var arg = args[name];

    if (arg instanceof FluentType) {
      return arg;
    }

    // Convert the argument to a Fluent type.
    switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {
      case 'string':
        return arg;
      case 'number':
        return new FluentNumber(arg);
      case 'object':
        if (arg instanceof Date) {
          return new FluentDateTime(arg);
        }
      default:
        errors.push(new TypeError('Unsupported external type: ' + name + ', ' + (typeof arg === 'undefined' ? 'undefined' : _typeof(arg))));
        return new FluentNone(name);
    }
  }

  /**
   * Resolve a reference to a function.
   *
   * @private
   */
  function FunctionReference(env, _ref11) {
    var name = _ref11.name;

    // Some functions are built-in.  Others may be provided by the runtime via
    // the `MessageContext` constructor.
    var functions = env.ctx.functions,
        errors = env.errors;

    var func = functions[name] || builtins[name];

    if (!func) {
      errors.push(new ReferenceError('Unknown function: ' + name + '()'));
      return new FluentNone(name + '()');
    }

    if (typeof func !== 'function') {
      errors.push(new TypeError('Function ' + name + '() is not callable'));
      return new FluentNone(name + '()');
    }

    return func;
  }

  /**
   * Resolve a call to a Function with positional and key-value arguments.
   *
   * @private
   */
  function CallExpression(env, _ref12) {
    var fun = _ref12.fun,
        args = _ref12.args;

    var callee = FunctionReference(env, fun);

    if (callee instanceof FluentNone) {
      return callee;
    }

    var posargs = [];
    var keyargs = [];

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = args[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var arg = _step4.value;

        if (arg.type === 'narg') {
          keyargs[arg.name] = Type(env, arg.val);
        } else {
          posargs.push(Type(env, arg));
        }
      }

      // XXX functions should also report errors
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    return callee(posargs, keyargs);
  }

  /**
   * Resolve a pattern (a complex string with placeables).
   *
   * @private
   */
  function Pattern(env, ptn) {
    var ctx = env.ctx,
        dirty = env.dirty,
        errors = env.errors;


    if (dirty.has(ptn)) {
      errors.push(new RangeError('Cyclic reference'));
      return new FluentNone();
    }

    // Tag the pattern as dirty for the purpose of the current resolution.
    dirty.add(ptn);
    var result = [];

    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = ptn[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var elem = _step5.value;

        if (typeof elem === 'string') {
          result.push(elem);
          continue;
        }

        var part = Type(env, elem);

        if (ctx.useIsolating) {
          result.push(FSI);
        }

        if (Array.isArray(part)) {
          var len = PlaceableLength(env, part);

          if (len > MAX_PLACEABLE_LENGTH) {
            errors.push(new RangeError('Too many characters in placeable ' + ('(' + len + ', max allowed is ' + MAX_PLACEABLE_LENGTH + ')')));
            result.push(new FluentNone());
          } else {
            result.push.apply(result, _toConsumableArray(part));
          }
        } else {
          result.push(part);
        }

        if (ctx.useIsolating) {
          result.push(PDI);
        }
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5.return) {
          _iterator5.return();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }

    dirty.delete(ptn);
    return result;
  }

  /**
   * Format a translation into an `FluentType`.
   *
   * The return value must be unwrapped via `valueOf` by the caller.
   *
   * @param   {MessageContext} ctx
   * @param   {Object}         args
   * @param   {Object}         message
   * @param   {Array}          errors
   * @returns {FluentType}
   */
  function resolve(ctx, args, message) {
    var errors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

    var env = {
      ctx: ctx, args: args, errors: errors, dirty: new WeakSet()
    };
    return Type(env, message);
  }

  /**
   * Message contexts are single-language stores of translations.  They are
   * responsible for parsing translation resources in the Fluent syntax and can
   * format translation units (entities) to strings.
   *
   * Always use `MessageContext.format` to retrieve translation units from
   * a context.  Translations can contain references to other entities or
   * external arguments, conditional logic in form of select expressions, traits
   * which describe their grammatical features, and can use Fluent builtins which
   * make use of the `Intl` formatters to format numbers, dates, lists and more
   * into the context's language.  See the documentation of the Fluent syntax for
   * more information.
   */

  var MessageContext = function () {

    /**
     * Create an instance of `MessageContext`.
     *
     * The `locales` argument is used to instantiate `Intl` formatters used by
     * translations.  The `options` object can be used to configure the context.
     *
     * Examples:
     *
     *     const ctx = new MessageContext(locales);
     *
     *     const ctx = new MessageContext(locales, { useIsolating: false });
     *
     *     const ctx = new MessageContext(locales, {
     *       useIsolating: true,
     *       functions: {
     *         NODE_ENV: () => process.env.NODE_ENV
     *       }
     *     });
     *
     * Available options:
     *
     *   - `functions` - an object of additional functions available to
     *                   translations as builtins.
     *
     *   - `useIsolating` - boolean specifying whether to use Unicode isolation
     *                    marks (FSI, PDI) for bidi interpolations.
     *
     * @param   {string|Array<string>} locales - Locale or locales of the context
     * @param   {Object} [options]
     * @returns {MessageContext}
     */
    function MessageContext(locales) {
      var _ref13 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref13$functions = _ref13.functions,
          functions = _ref13$functions === undefined ? {} : _ref13$functions,
          _ref13$useIsolating = _ref13.useIsolating,
          useIsolating = _ref13$useIsolating === undefined ? true : _ref13$useIsolating;

      _classCallCheck(this, MessageContext);

      this.locales = Array.isArray(locales) ? locales : [locales];
      this.functions = functions;
      this.useIsolating = useIsolating;
      this.messages = new Map();
      this.intls = new WeakMap();
    }

    /**
     * Add a translation resource to the context.
     *
     * The translation resource must use the Fluent syntax.  It will be parsed by
     * the context and each translation unit (message) will be available in the
     * `messages` map by its identifier.
     *
     *     ctx.addMessages('foo = Foo');
     *     ctx.messages.get('foo');
     *
     *     // Returns a raw representation of the 'foo' message.
     *
     * Parsed entities should be formatted with the `format` method in case they
     * contain logic (references, select expressions etc.).
     *
     * @param   {string} source - Text resource with translations.
     * @returns {Array<Error>}
     */


    _createClass(MessageContext, [{
      key: 'addMessages',
      value: function addMessages(source) {
        var _parse = parse(source),
            _parse2 = _slicedToArray(_parse, 2),
            entries = _parse2[0],
            errors = _parse2[1];

        for (var id in entries) {
          this.messages.set(id, entries[id]);
        }

        return errors;
      }

      /**
       * Format a message to an array of `FluentTypes` or null.
       *
       * Format a raw `message` from the context's `messages` map into an array of
       * `FluentType` instances which may be used to build the final result.  It
       * may also return `null` if it has a null value.  `args` will be used to
       * resolve references to external arguments inside of the translation.
       *
       * See the documentation of {@link MessageContext#format} for more
       * information about error handling.
       *
       * In case of errors `format` will try to salvage as much of the translation
       * as possible and will still return a string.  For performance reasons, the
       * encountered errors are not returned but instead are appended to the
       * `errors` array passed as the third argument.
       *
       *     ctx.addMessages('hello = Hello, { $name }!');
       *     const hello = ctx.messages.get('hello');
       *     ctx.formatToParts(hello, { name: 'Jane' }, []);
       *     // â†’ ['Hello, ', '\u2068', 'Jane', '\u2069']
       *
       * The returned parts need to be formatted via `valueOf` before they can be
       * used further.  This will ensure all values are correctly formatted
       * according to the `MessageContext`'s locale.
       *
       *     const parts = ctx.formatToParts(hello, { name: 'Jane' }, []);
       *     const str = parts.map(part => part.valueOf(ctx)).join('');
       *
       * @see MessageContext#format
       * @param   {Object | string}    message
       * @param   {Object | undefined} args
       * @param   {Array}              errors
       * @returns {?Array<FluentType>}
       */

    }, {
      key: 'formatToParts',
      value: function formatToParts(message, args, errors) {
        // optimize entities which are simple strings with no attributes
        if (typeof message === 'string') {
          return [message];
        }

        // optimize simple-string entities with attributes
        if (typeof message.val === 'string') {
          return [message.val];
        }

        // optimize entities with null values
        if (message.val === undefined) {
          return null;
        }

        var result = resolve(this, args, message, errors);

        return result instanceof FluentNone ? null : result;
      }

      /**
       * Format a message to a string or null.
       *
       * Format a raw `message` from the context's `messages` map into a string (or
       * a null if it has a null value).  `args` will be used to resolve references
       * to external arguments inside of the translation.
       *
       * In case of errors `format` will try to salvage as much of the translation
       * as possible and will still return a string.  For performance reasons, the
       * encountered errors are not returned but instead are appended to the
       * `errors` array passed as the third argument.
       *
       *     const errors = [];
       *     ctx.addMessages('hello = Hello, { $name }!');
       *     const hello = ctx.messages.get('hello');
       *     ctx.format(hello, { name: 'Jane' }, errors);
       *
       *     // Returns 'Hello, Jane!' and `errors` is empty.
       *
       *     ctx.format(hello, undefined, errors);
       *
       *     // Returns 'Hello, name!' and `errors` is now:
       *
       *     [<ReferenceError: Unknown external: name>]
       *
       * @param   {Object | string}    message
       * @param   {Object | undefined} args
       * @param   {Array}              errors
       * @returns {?string}
       */

    }, {
      key: 'format',
      value: function format(message, args, errors) {
        var _this5 = this;

        // optimize entities which are simple strings with no attributes
        if (typeof message === 'string') {
          return message;
        }

        // optimize simple-string entities with attributes
        if (typeof message.val === 'string') {
          return message.val;
        }

        // optimize entities with null values
        if (message.val === undefined) {
          return null;
        }

        var result = resolve(this, args, message, errors);

        if (result instanceof FluentNone) {
          return null;
        }

        return result.map(function (part) {
          return part.valueOf(_this5);
        }).join('');
      }
    }, {
      key: '_memoizeIntlObject',
      value: function _memoizeIntlObject(ctor, opts) {
        var cache = this.intls.get(ctor) || {};
        var id = JSON.stringify(opts);

        if (!cache[id]) {
          cache[id] = new ctor(this.locales, opts);
          this.intls.set(ctor, cache);
        }

        return cache[id];
      }
    }]);

    return MessageContext;
  }();

  exports._parse = parse;
  exports.MessageContext = MessageContext;
  exports.MessageArgument = FluentType;
  exports.MessageNumberArgument = FluentNumber;
  exports.MessageDateTimeArgument = FluentDateTime;

  Object.defineProperty(exports, '__esModule', { value: true });
});

