/* fluent-langneg@0.0.3 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define('fluent-langneg', ['exports'], factory) :
	(factory((global.FluentLangNeg = global.FluentLangNeg || {})));
}(this, (function (exports) { 'use strict';

function acceptedLanguages() {
  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  if (typeof string !== 'string') {
    throw new TypeError('Argument must be a string');
  }
  var tokens = string.split(',').map(function (t) {
    return t.trim();
  });
  return tokens.filter(function (t) {
    return t !== '';
  }).map(function (t) {
    return t.split(';')[0];
  });
}

/**
 * Below is a manually a list of likely subtags corresponding to Unicode
 * CLDR likelySubtags list.
 * This list is curated by the maintainers of Project Fluent and is
 * intended to be used in place of the full likelySubtags list in use cases
 * where full list cannot be (for example, due to the size).
 *
 * This version of the list is based on CLDR 30.0.3.
 */
var likelySubtagsMin = {
  'ar': 'ar-arab-eg',
  'az-arab': 'az-arab-ir',
  'az-ir': 'az-arab-ir',
  'be': 'be-cyrl-by',
  'da': 'da-latn-dk',
  'el': 'el-grek-gr',
  'en': 'en-latn-us',
  'fa': 'fa-arab-ir',
  'ja': 'ja-jpan-jp',
  'ko': 'ko-kore-kr',
  'pt': 'pt-latn-br',
  'sr': 'sr-cyrl-rs',
  'sr-ru': 'sr-latn-ru',
  'sv': 'sv-latn-se',
  'ta': 'ta-taml-in',
  'uk': 'uk-cyrl-ua',
  'zh': 'zh-hans-cn',
  'zh-gb': 'zh-hant-gb',
  'zh-us': 'zh-hant-us'
};

var regionMatchingLangs = ['az', 'bg', 'cs', 'de', 'es', 'fi', 'fr', 'hu', 'it', 'lt', 'lv', 'nl', 'pl', 'ro', 'ru'];

function getLikelySubtagsMin(loc) {
  if (likelySubtagsMin.hasOwnProperty(loc)) {
    return new Locale(likelySubtagsMin[loc]);
  }
  var locale = new Locale(loc);
  if (regionMatchingLangs.includes(locale.language)) {
    locale.region = locale.language;
    locale.string = locale.language + '-' + locale.region;
    return locale;
  }
  return null;
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/* eslint no-magic-numbers: 0 */

var languageCodeRe = '([a-z]{2,3}|\\*)';
var scriptCodeRe = '(?:-([a-z]{4}|\\*))';
var regionCodeRe = '(?:-([a-z]{2}|\\*))';
var variantCodeRe = '(?:-([a-z]{3}|\\*))';

/**
 * Regular expression splitting locale id into four pieces:
 *
 * Example: `en-Latn-US-mac`
 *
 * language: en
 * script:   Latn
 * region:   US
 * variant:  mac
 *
 * It can also accept a range `*` character on any position.
 */
var localeRe = new RegExp('^' + languageCodeRe + scriptCodeRe + '?' + regionCodeRe + '?' + variantCodeRe + '?$', 'i');

var localeParts = ['language', 'script', 'region', 'variant'];

var Locale = function () {
  /**
   * Parses a locale id using the localeRe into an array with four elements.
   *
   * If the second argument `range` is set to true, it places range `*` char
   * in place of any missing piece.
   *
   * It also allows skipping the script section of the id, so `en-US` is
   * properly parsed as `en-*-US-*`.
   */
  function Locale(locale) {
    var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    classCallCheck(this, Locale);

    var result = localeRe.exec(locale.replace(/_/g, '-'));
    if (!result) {
      return;
    }

    var missing = range ? '*' : undefined;

    var language = result[1] || missing;
    var script = result[2] || missing;
    var region = result[3] || missing;
    var variant = result[4] || missing;

    this.language = language;
    this.script = script;
    this.region = region;
    this.variant = variant;
    this.string = locale;
  }

  createClass(Locale, [{
    key: 'isEqual',
    value: function isEqual(locale) {
      var _this = this;

      return localeParts.every(function (part) {
        return _this[part] === locale[part];
      });
    }
  }, {
    key: 'matches',
    value: function matches(locale) {
      var _this2 = this;

      return localeParts.every(function (part) {
        return _this2[part] === '*' || locale[part] === '*' || _this2[part] === undefined && locale[part] === undefined || _this2[part] !== undefined && locale[part] !== undefined && _this2[part].toLowerCase() === locale[part].toLowerCase();
      });
    }
  }, {
    key: 'setVariantRange',
    value: function setVariantRange() {
      this.variant = '*';
    }
  }, {
    key: 'setRegionRange',
    value: function setRegionRange() {
      this.region = '*';
    }
  }, {
    key: 'addLikelySubtags',
    value: function addLikelySubtags() {
      var _this3 = this;

      var newLocale = getLikelySubtagsMin(this.string.toLowerCase());

      if (newLocale) {
        localeParts.forEach(function (part) {
          return _this3[part] = newLocale[part];
        });
        this.string = newLocale.string;
        return true;
      }
      return false;
    }
  }]);
  return Locale;
}();

/* eslint no-magic-numbers: 0 */
/* eslint complexity: ["error", { "max": 27 }] */

/**
 * Negotiates the languages between the list of requested locales against
 * a list of available locales.
 *
 * The algorithm is based on the BCP4647 3.3.2 Extended Filtering algorithm,
 * with several modifications:
 *
 *  1) available locales are treated as ranges
 *
 *    This change allows us to match a more specific request against
 *    more generic available locale.
 *
 *    For example, if the available locale list provides locale `en`,
 *    and the requested locale is `en-US`, we treat the available locale as
 *    a locale that matches all possible english requests.
 *
 *    This means that we expect available locale ID to be as precize as
 *    the matches they want to cover.
 *
 *    For example, if there is only `sr` available, it's ok to list
 *    it in available locales. But once the available locales has both,
 *    Cyrl and Latn variants, the locale IDs should be `sr-Cyrl` and `sr-Latn`
 *    to avoid any `sr-*` request to match against whole `sr` range.
 *
 *    What it does ([requested] * [available] = [supported]):
 *
 *    ['en-US'] * ['en'] = ['en']
 *
 *  2) likely subtags from LDML 4.3 Likely Subtags has been added
 *
 *    The most obvious likely subtag that can be computed is a duplication
 *    of the language field onto region field (`fr` => `fr-FR`).
 *
 *    On top of that, likely subtags may use a list of mappings, that
 *    allow the algorithm to handle non-obvious matches.
 *    For example, making sure that we match `en` to `en-US` or `sr` to
 *    `sr-Cyrl`, while `sr-RU` to `sr-Latn-RU`.
 *
 *    This list can be taken directly from CLDR Supplemental Data.
 *
 *    What it does ([requested] * [available] = [supported]):
 *
 *    ['fr'] * ['fr-FR'] = ['fr-FR']
 *    ['en'] * ['en-US'] = ['en-US']
 *    ['sr'] * ['sr-Latn', 'sr-Cyrl'] = ['sr-Cyrl']
 *
 *  3) variant/region range check has been added
 *
 *    Lastly, the last form of check is against the requested locale ID
 *    but with the variant/region field replaced with a `*` range.
 *
 *    The rationale here laid out in LDML 4.4 Language Matching:
 *      "(...) normally the fall-off between the user's languages is
 *      substantially greated than regional variants."
 *
 *    In other words, if we can't match for the given region, maybe
 *    we can match for the same language/script but other region, and
 *    it will in most cases be preferred over falling back on the next
 *    language.
 *
 *    What it does ([requested] * [available] = [supported]):
 *
 *    ['en-AU'] * ['en-US'] = ['en-US']
 *    ['sr-RU'] * ['sr-Latn-RO'] = ['sr-Latn-RO'] // sr-RU -> sr-Latn-RU
 *
 *    It works similarly to getParentLocales algo, except that we stop
 *    after matching against variant/region ranges and don't try to match
 *    ignoring script ranges. That means that `sr-Cyrl` will never match
 *    against `sr-Latn`.
 */
function filterMatches(requestedLocales, availableLocales, strategy) {
  var supportedLocales = new Set();

  var availLocales = new Set(availableLocales.map(function (locale) {
    return new Locale(locale, true);
  }));

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    outer: for (var _iterator = requestedLocales[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var reqLocStr = _step.value;

      var reqLocStrLC = reqLocStr.toLowerCase();
      var requestedLocale = new Locale(reqLocStrLC);

      if (requestedLocale.language === undefined) {
        continue;
      }

      // Attempt to make an exact match
      // Example: `en-US` === `en-US`
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = availableLocales[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _availableLocale = _step2.value;

          if (reqLocStrLC === _availableLocale.toLowerCase()) {
            supportedLocales.add(_availableLocale);
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = availLocales[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var loc = _step7.value;

                if (loc.isEqual(requestedLocale)) {
                  availLocales.delete(loc);
                  break;
                }
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                  _iterator7.return();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }

            if (strategy === 'lookup') {
              return Array.from(supportedLocales);
            } else if (strategy === 'filtering') {
              continue;
            } else {
              continue outer;
            }
          }
        }

        // Attempt to match against the available range
        // This turns `en` into `en-*-*-*` and `en-US` into `en-*-US-*`
        // Example: ['en-US'] * ['en'] = ['en']
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = availLocales[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _availableLocale2 = _step3.value;

          if (requestedLocale.matches(_availableLocale2)) {
            supportedLocales.add(_availableLocale2.string);
            availLocales.delete(_availableLocale2);
            if (strategy === 'lookup') {
              return Array.from(supportedLocales);
            } else if (strategy === 'filtering') {
              continue;
            } else {
              continue outer;
            }
          }
        }

        // Attempt to retrieve a maximal version of the requested locale ID
        // If data is available, it'll expand `en` into `en-Latn-US` and
        // `zh` into `zh-Hans-CN`.
        // Example: ['en'] * ['en-GB', 'en-US'] = ['en-US']
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (requestedLocale.addLikelySubtags()) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = availLocales[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var availableLocale = _step4.value;

            if (requestedLocale.matches(availableLocale)) {
              supportedLocales.add(availableLocale.string);
              availLocales.delete(availableLocale);
              if (strategy === 'lookup') {
                return Array.from(supportedLocales);
              } else if (strategy === 'filtering') {
                continue;
              } else {
                continue outer;
              }
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }

      // Attempt to look up for a different variant for the same locale ID
      // Example: ['en-US-mac'] * ['en-US-win'] = ['en-US-win']
      requestedLocale.setVariantRange();

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = availLocales[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _availableLocale3 = _step5.value;

          if (requestedLocale.matches(_availableLocale3)) {
            supportedLocales.add(_availableLocale3.string);
            availLocales.delete(_availableLocale3);
            if (strategy === 'lookup') {
              return Array.from(supportedLocales);
            } else if (strategy === 'filtering') {
              continue;
            } else {
              continue outer;
            }
          }
        }

        // Attempt to look up for a different region for the same locale ID
        // Example: ['en-US'] * ['en-AU'] = ['en-AU']
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      requestedLocale.setRegionRange();

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = availLocales[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _availableLocale4 = _step6.value;

          if (requestedLocale.matches(_availableLocale4)) {
            supportedLocales.add(_availableLocale4.string);
            availLocales.delete(_availableLocale4);
            if (strategy === 'lookup') {
              return Array.from(supportedLocales);
            } else if (strategy === 'filtering') {
              continue;
            } else {
              continue outer;
            }
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return Array.from(supportedLocales);
}

/*
 * @module fluent-langneg
 * @overview
 *
 * `fluent-langneg` provides language negotiation API that fits into
 * Project Fluent localization composition and fallbacking strategy.
 *
 */

function GetOption(options, property, type, values, fallback) {
  var value = options[property];

  if (value !== undefined) {
    if (type === 'boolean') {
      value = new Boolean(value);
    } else if (type === 'string') {
      value = String(value);
    }

    if (values !== undefined && values.indexOf(value) === -1) {
      throw new Error('Invalid option value');
    }

    return value;
  }

  return fallback;
}

/**
 * Negotiates the languages between the list of requested locales against
 * a list of available locales.
 *
 * It accepts three arguments:
 *
 *   requestedLocales:
 *     an Array of strings with BCP47 locale IDs sorted
 *     according to user preferences.
 *
 *   availableLocales:
 *     an Array of strings with BCP47 locale IDs of locale for which
 *     resources are available. Unsorted.
 *
 *   options:
 *     An object with the following, optional keys:
 *
 *       strategy: 'filtering' (default) | 'matching' | 'lookup'
 *
 *       defaultLocale:
 *         a string with BCP47 locale ID to be used
 *         as a last resort locale.
 *
 *       likelySubtags:
 *         a key-value map of locale keys to their most expanded variants.
 *         For example:
 *           'en' -> 'en-Latn-US',
 *           'ru' -> 'ru-Cyrl-RU',
 *
 *
 * It returns an Array of strings with BCP47 locale IDs sorted according to the
 * user preferences.
 *
 * The exact list will be selected differently depending on the strategy:
 *
 *   'filtering': (default)
 *     In the filtering strategy, the algorithm will attempt to match
 *     as many keys in the available locales in order of the requested locales.
 *
 *   'matching':
 *     In the matching strategy, the algorithm will attempt to find the
 *     best possible match for each element of the requestedLocales list.
 *
 *   'lookup':
 *     In the lookup strategy, the algorithm will attempt to find a single
 *     best available locale based on the requested locales list.
 *
 *     This strategy requires defaultLocale option to be set.
 */
function negotiateLanguages(requestedLocales, availableLocales) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


  var defaultLocale = GetOption(options, 'defaultLocale', 'string');
  var likelySubtags = GetOption(options, 'likelySubtags', 'object', undefined);
  var strategy = GetOption(options, 'strategy', 'string', ['filtering', 'matching', 'lookup'], 'filtering');

  if (strategy === 'lookup' && !defaultLocale) {
    throw new Error('defaultLocale cannot be undefined for strategy `lookup`');
  }

  var resolvedReqLoc = Array.from(Object(requestedLocales)).map(function (loc) {
    return String(loc);
  });
  var resolvedAvailLoc = Array.from(Object(availableLocales)).map(function (loc) {
    return String(loc);
  });

  var supportedLocales = filterMatches(resolvedReqLoc, resolvedAvailLoc, strategy, likelySubtags);

  if (strategy === 'lookup') {
    if (supportedLocales.length === 0) {
      supportedLocales.push(defaultLocale);
    }
  } else if (defaultLocale && !supportedLocales.includes(defaultLocale)) {
    supportedLocales.push(defaultLocale);
  }
  return supportedLocales;
}

exports['default'] = negotiateLanguages;
exports.acceptedLanguages = acceptedLanguages;

Object.defineProperty(exports, '__esModule', { value: true });

})));
